#----------------------------------------------------------------------------------------------------
#' @name Trena-class
#' @rdname Trena-class
#' @aliases Trena
#'
#' @import methods

.Trena <- setClass ("Trena",
                    representation = representation(
                       genomeName="character",
                       quiet="logical")
                        )
#------------------------------------------------------------------------------------------------------------------------
#' Get the regulatory chromosomal regions for a Trena object
#'
#' @rdname getRegulatoryChromosomalRegions
#' @aliases getRegulatoryChromosomalRegions
#'
#' @param obj An object of class Trena
#' @param chromosome A choromosome of interest
#' @param chromStart The beginning of the desired region
#' @param chromEnd The end of the desired region
#' @param regulatoryRegionSources A vector containing the names of sources for chromosome information. These can be
#' addresses of footprint databases or the names of DHS databases
#' @param targetGene A target gene of interest
#' @param targetGeneTSS An integer giving the location of the target gene's transcription start site
#' @param combine A logical indicating whether or not to combine the output into one data frame (default = FALSE)
#' @param quiet A logical indicating whether or not the method should print output (default = FALSE)
#'
#' @export
#'
#' @return A list of regulatory regions for the supplied target gene. If \code{combine} is set to \code{TRUE},
#' the list is converted into a data frame.
#'
#' @examples
#' # Get regulatory regions for MEF2C from a footprint database
#' database.filename <- system.file(package="trena", "extdata", "project.sub.db")
#' database.uri <- sprintf("sqlite://%s", database.filename)
#' sources <- c(database.uri)
#'
#' trena <- Trena("hg38")
#' chromosome <- "chr5"
#' mef2c.tss <- 88904257
#' loc.start <- mef2c.tss - 1000
#' loc.end   <- mef2c.tss + 1000
#'
#' regions <- getRegulatoryChromosomalRegions(trena, chromosome, mef2c.tss-1000, mef2c.tss+1000,
#' sources, "MEF2C", mef2c.tss)
#'
#' # Get regulatory regions for AQP4 from a Human DHS source
#' trena <- Trena("hg38")
#' aqp4.tss <- 26865884
#' chromosome <- "chr18"
#' sources <- c("encodeHumanDHS")
#'
#' regions <- getRegulatoryChromosomalRegions(trena, chromosome, aqp4.tss-1, aqp4.tss+3, sources, "AQP4", aqp4.tss)

setGeneric('getRegulatoryChromosomalRegions',  signature='obj',
           function(obj, chromosome, chromStart, chromEnd, regulatoryRegionSources, targetGene, targetGeneTSS,
                    combine=FALSE) standardGeneric("getRegulatoryChromosomalRegions"))

#' Retrieve the column names in the regulatory table for a Trena object
#'
#' @rdname getRegulatoryTableColumnNames
#' @aliases getRegulatoryTableColumnNames
#'
#' @param obj An object of class Trena
#'
#' @return A character vector listing the column names in the Trena object regulatory table
#'
#' @export
#'
#' @examples
#' # Create a Trena object and retrieve the column names of the regulatory table
#' trena <- Trena("mm10")
#' tbl.cols <- getRegulatoryTableColumnNames(trena)

setGeneric('getRegulatoryTableColumnNames',  signature='obj', function(obj) standardGeneric ('getRegulatoryTableColumnNames'))

#' Retrieve the column names in the gene model table for a Trena object
#'
#' @rdname getGeneModelTableColumnNames
#' @aliases getGeneModelTableColumnNames
#'
#' @param obj An object of class Trena
#'
#' @return A character vector listing the column names in the Trena object gene model table
#'
#' @export
#'
#' @examples
#' # Create a Trena object and retrieve the column names of the gene model table
#' trena <- Trena("mm10")
#' tbl.cols <- getRegulatoryTableColumnNames(trena)

setGeneric('getGeneModelTableColumnNames',  signature='obj', function(obj) standardGeneric ('getGeneModelTableColumnNames'))

#' Create a model for a target gene using a Trena object
#'
#' @rdname createGeneModel
#' @aliases createGeneModel
#'
#' @param obj An object of class Trena
#' @param targetGene The name of a target gene to use for building a model
#' @param solverNames A character vector containing the solver names to be used for building the model
#' @param tbl.regulatoryRegions A data frame of regulatory regions, typically generated by using a filter
#' @param mtx An assay matrix of expression data
#'
#' @return A data frame containing the gene model
#'
#' @export
#'
#' @examples
#' # Create a Trena object for human and make a gene model for "MEF2C" using a footprint filter
#' trena <- Trena("hg38")
#' chromosome <- "chr5"
#' mef2c.tss <- 88904257
#' loc.start <- mef2c.tss - 1000
#' loc.end   <- mef2c.tss + 1000
#'
#' database.filename <- system.file(package="trena", "extdata", "project.sub.db")
#' database.uri <- sprintf("sqlite://%s", database.filename)
#' sources <- c(database.uri)
#' load(system.file(package="trena", "extdata/ampAD.154genes.mef2cTFs.278samples.RData"))
#'
#' motifs.list <- getRegulatoryChromosomalRegions(trena, chromosome, mef2c.tss-1000, mef2c.tss+1000,
#' sources, "MEF2C", mef2c.tss)
#'
#' library(MotifDb)
#' tbl.motifs.tfs <- associateTranscriptionFactors(MotifDb, motifs.list[[1]], source="MotifDb", expand.rows=TRUE)
#' model.mef2c <- createGeneModel(trena, "MEF2C", c("lasso","ridge","randomforest"), tbl.motifs.tfs, mtx.sub)

setGeneric('createGeneModel', signature='obj', function(obj, targetGene,  solverNames, tbl.regulatoryRegions, mtx)
    standardGeneric('createGeneModel'))

#setGeneric('addGeneModelLayout', signature='obj', function(obj, g, xPos.span=1500) standardGeneric('addGeneModelLayout'))

#' Assess the effect of a SNP using a Trena object
#'
#' @rdname assessSnp
#' @aliases assessSnp
#'
#' @param obj An object of class Trena
#' @param pfms A set of motif matrices, generally retrieved using MotifDb
#' @param variant A variant of interest
#' @param shoulder A distance from the TSS to use as a window
#' @param pwmMatchMinimumAsPercentage A minimum match percentage for the  motifs
#' @param genomeName A genome name (one of "hg38", "hg19", "mm10")
#'
#' @return A data frame containing the gene model
#'
#' @export
#'
#' @examples
#' # Create a Trena object for human, retrieve regions for "MEF2C" using a footprint filter,
#' # and then add the TF column
#' trena <- Trena("hg38")
#' chromosome <- "chr5"
#' mef2c.tss <- 88904257
#' loc.start <- mef2c.tss - 1000
#' loc.end   <- mef2c.tss + 1000
#'
#'
#'
#'

setGeneric('assessSnp', signature='obj', function(obj, pfms, variant, shoulder, pwmMatchMinimumAsPercentage, relaxedMatchDelta=25)
              standardGeneric('assessSnp'))
#------------------------------------------------------------------------------------------------------------------------
# a temporary hack: some constants
genome.db.uri <- "postgres://bddsrds.globusgenomics.org/hg38"   # has gtf and motifsgenes tables
#------------------------------------------------------------------------------------------------------------------------
#' Define an object of class Trena
#'
#' @description
#' The Trena class provides a convenient wrapper for the most commonly used filters and solver in the \code{trena}
#' package. Given a particular genome (one of \code{c("hg19","hg38","mm10")}, the Trena class provides methods to
#' retrieve information about possible regulators for a target gene, assess the effects of SNPs, and create gene models
#' using the flexible \code{\link{EnsembleSolver}} class.
#'
#' @param genomeName A string indicating the genome used by the Trena object. Currently, only human and mouse ("hg19",
#' "hg38","mm10") are supported
#' @param quiet A logical indicating whether or not the Trena object should print output
#'
#' @return An object of the Trena class
#'
#' @export
#'
#' @examples
#' # Create a Trena object using the human hg38 genome
#' trena <- Trena("hg38")
#'
#' @seealso \code{\link{getRegulatoryChromosomalRegions}}, \code{\link{getRegulatoryTableColumnNames}},
#' \code{\link{getGeneModelTableColumnNames}}, \code{\link{createGeneModel}},
#' \code{\link{assessSnp}}

Trena = function(genomeName, quiet=TRUE)
{
   stopifnot(genomeName %in% c("hg19", "hg38", "mm10"))

   obj <- .Trena(genomeName=genomeName, quiet=quiet)

   obj

} # constructor
#------------------------------------------------------------------------------------------------------------------------
setMethod('getRegulatoryTableColumnNames', 'Trena',

      function(obj){
         c("chrom", "motifStart", "motifEnd", "motifName", "strand", "score", "length", "distance.from.tss", "id")
         })

#------------------------------------------------------------------------------------------------------------------------
setMethod('getGeneModelTableColumnNames', 'Trena',

      function(obj){
         c("tf", "randomForest", "pearson", "spearman", "betaLasso", "pcaMax", "concordance")
         })

#------------------------------------------------------------------------------------------------------------------------
.callFootprintFilter <- function(obj, source, chromosome, chromStart, chromEnd, targetGene, targetGeneTSS)
{
    chromLocString <- sprintf("%s:%d-%d", chromosome, chromStart, chromEnd)
    fpFilter <- FootprintFilter(genome.db.uri, source,
                                regions=data.frame(chrom=chromosome, start=chromStart, end=chromEnd, stringsAsFactors=FALSE))
    tbl.fp <- getCandidates(fpFilter)

    if(nrow(tbl.fp) == 0){
       warning("no footprints found in %s:%d-%d, targetGene is %s", chromosome, chromeStart, chromEnd, targetGene);
       return(tbl.fp)
       }

    colnames.raw <- c("loc", "chrom", "start", "endpos", "fp_start", "fp_end", "type", "name", "length", "strand",
                      "sample_id", "method", "provenance", "score1", "score2", "score3", "score4", "score5", "score6")
    tbl.fp <- tbl.fp[, c("chrom", "start", "endpos", "name", "length", "strand", "score1", "score2", "score3")]
    colnames(tbl.fp) <- c("chrom", "motifStart", "motifEnd", "motifName", "length", "strand", "score1", "score", "score3")

    distance <- tbl.fp$motifStart - targetGeneTSS
    direction <- rep("upstream", length(distance))
    direction[which(distance < 0)] <- "downstream"
    tbl.fp$distance.from.tss <- distance
    tbl.fp$id <- sprintf("%s.fp.%s.%06d.%s", targetGene, direction, abs(distance), tbl.fp$motifName)
      # a final rearrangement of columns, to match our standard
    tbl.fp <- tbl.fp[, getRegulatoryTableColumnNames(obj)]

    tbl.fp

} # .callFootprintFilter
#------------------------------------------------------------------------------------------------------------------------
.callHumanDHSFilter <- function(obj, chromosome, chromStart, chromEnd, targetGene, targetGeneTSS)
{
    if(!obj@quiet) printf("--- in .callHumanDHS")
    chromLocString <- sprintf("%s:%d-%d", chromosome, chromStart, chromEnd)
    dhsFilter <- HumanDHSFilter(genome="hg38",
                                encodeTableName="wgEncodeRegDnaseClustered",
                                pwmMatchPercentageThreshold=85L,
                                geneInfoDatabase.uri=genome.db.uri,
                                regions=data.frame(chrom=chromosome,
                                                   start=chromStart,
                                                   end=chromEnd,
                                                   stringsAsFactors=FALSE))

    tbl.dhs <- getCandidates(dhsFilter)
    if(nrow(tbl.dhs) == 0)
      return(tbl.dhs)

    tbl.dhs$length <- nchar(tbl.dhs$match)
    distance <- tbl.dhs$motifStart - targetGeneTSS
    direction <- rep("upstream", length(distance))
    direction[which(distance < 0)] <- "downstream"

    colnames(tbl.dhs)[grep("motifRelativeScore", colnames(tbl.dhs))] <- "score"
    #colnames(tbl.dhs)[grep("tfs", colnames(tbl.dhs))] <- "tf"
    tbl.dhs$distance.from.tss <- distance
    tbl.dhs$id <- sprintf("%s.dhs.%s.%06d.%s", targetGene, direction, abs(distance), tbl.dhs$motifName)

    tbl.dhs <- tbl.dhs[, getRegulatoryTableColumnNames(obj)]

    tbl.dhs

} # .callHumanDHSFilter
#------------------------------------------------------------------------------------------------------------------------
setMethod('getRegulatoryChromosomalRegions', 'Trena',

    function(obj, chromosome, chromStart, chromEnd, regulatoryRegionSources, targetGene, targetGeneTSS,
             combine=FALSE){

         tbl.combined <- data.frame()
         result <- list()
           # some bookeeeping to permit duplicate sources, useful only in testing
         source.count <- 0
         all.source.names <- regulatoryRegionSources

         encodeDHS.source.index <- grep("encodeHumanDHS", regulatoryRegionSources)

         if(length(encodeDHS.source.index)){
            source.count <- source.count + 1
            regulatoryRegionSources <- regulatoryRegionSources[-encodeDHS.source.index]
            if(!obj@quiet) printf("about to callHumanDHSFilter");
            tbl.dhs <- .callHumanDHSFilter(obj, chromosome, chromStart, chromEnd, targetGene, targetGeneTSS)
            result[[source.count]] <- tbl.dhs
            if(combine)
               tbl.combined <- rbind(tbl.combined, tbl.dhs)
            } # if encode DSH source requested


         for(source in regulatoryRegionSources){
            source.count <- source.count + 1
            if(!obj@quiet) printf("about to call footprintFilter with source = '%s'", source);
            tbl.fp <- .callFootprintFilter(obj, source, chromosome, chromStart, chromEnd, targetGene, targetGeneTSS)
            if(combine)
               tbl.combined <- rbind(tbl.combined, tbl.fp)
            result[[source.count]] <- tbl.fp
            } # for source
         names(result) <- all.source.names
         if(combine)
            result[["all"]] <- tbl.combined
         result
         }) # getRegulatoryChromosomalRegions

#------------------------------------------------------------------------------------------------------------------------
setMethod('createGeneModel', 'Trena',

      function(obj, targetGene, solverNames, tbl.regulatoryRegions, mtx){

         stopifnot("geneSymbol" %in% colnames(tbl.regulatoryRegions))
         unique.tfs.from.regulatory.regions <- unique(tbl.regulatoryRegions$geneSymbol)
         tfs <- intersect(unique.tfs.from.regulatory.regions, rownames(mtx))
         if(!obj@quiet)
            printf("tf candidate count, in mtx, in tbl.regulatory.regions: %d/%d", length(tfs),
                   length(unique.tfs.from.regulatory.regions))

         solver <- EnsembleSolver(mtx, targetGene=targetGene, candidateRegulators=tfs, solverNames)
         tbl.model <- run(solver)
         tbl.tf.frequencies <- as.data.frame(table(tbl.regulatoryRegions$geneSymbol))
         colnames(tbl.tf.frequencies) <- c("gene", "binding.sites")
         tbl.model <- merge(tbl.model, tbl.tf.frequencies, by="gene")
         tbl.model <- tbl.model[order(tbl.model$pcaMax, decreasing=TRUE),]
         tbl.model
      }) # createGeneModel

#------------------------------------------------------------------------------------------------------------------------
setMethod('assessSnp', 'Trena',

     function(obj, pfms, variant, shoulder, pwmMatchMinimumAsPercentage, relaxedMatchDelta=25){

        motifMatcher <- MotifMatcher(genomeName=obj@genomeName, pfms=pfms, quiet=obj@quiet)
        tbl.variant <- try(trena:::.parseVariantString(motifMatcher, variant), silent=TRUE)
        if(is(tbl.variant, "try-error")){
           printf("error, unrecognized variant name: '%s'", variant)
           return(data.frame())
           }
        tbl.regions <- data.frame(chrom=tbl.variant$chrom,
                                  start=tbl.variant$loc-shoulder,
                                  end=tbl.variant$loc+shoulder,
                                  stringsAsFactors=FALSE)

        tbl.wt  <- findMatchesByChromosomalRegion(motifMatcher, tbl.regions,
                                                  pwmMatchMinimumAsPercentage=pwmMatchMinimumAsPercentage)
        if(nrow(tbl.wt) == 0){
           warning(sprintf("no motifs found in reference sequence in neighborhood of %s with shoulder %d",
                           variant, shoulder))
           return(data.frame())
           }

       tbl.mut <- findMatchesByChromosomalRegion(motifMatcher, tbl.regions,
                                                 pwmMatchMinimumAsPercentage=pwmMatchMinimumAsPercentage,
                                                 variant=variant)
       if(nrow(tbl.mut) == 0){
          warning(sprintf("no motifs altered by %s with shoulder %d", variant, shoulder))
          return(data.frame())
          }

        tbl.wt$signature <- sprintf("%s;%s;%s", tbl.wt$motifName, tbl.wt$motifStart, tbl.wt$strand)
        tbl.mut$signature <- sprintf("%s;%s;%s", tbl.mut$motifName, tbl.mut$motifStart, tbl.mut$strand)

            # comine wt and mut tables, reorder columns and rows for easier comprehension
        tbl <- rbind(tbl.wt[, c(1,12,2,3,4,5,6,7,8,13)], tbl.mut[, c(1,12,2,3,4,5,6,7,8,13)])
        tbl <- tbl[order(tbl$motifName, tbl$motifRelativeScore, decreasing=TRUE),]
        #tbl$signature <- sprintf("%s;%s;%s", tbl$motifName, tbl$motifStart, tbl$strand)
        tbl <- tbl[,c(1,2,3:10)]

            # now look for less stringent matches.  these will be matched up with the
            # wt and mut motifs which do not yet have partners, thus enabling us to
            # provide a wt->mut motifScore.delta for each
        relaxedMatchPercentage <- pwmMatchMinimumAsPercentage-relaxedMatchDelta
        tbl.wt.relaxed <- findMatchesByChromosomalRegion(motifMatcher, tbl.regions, relaxedMatchPercentage)
        tbl.wt.relaxed$signature <- sprintf("%s;%s;%s", tbl.wt.relaxed$motifName, tbl.wt.relaxed$motifStart, tbl.wt.relaxed$strand)
        tbl.mut.relaxed <- findMatchesByChromosomalRegion(motifMatcher, tbl.regions, relaxedMatchPercentage, variant=variant)
        tbl.mut.relaxed$signature <- sprintf("%s;%s;%s", tbl.mut.relaxed$motifName, tbl.mut.relaxed$motifStart, tbl.mut.relaxed$strand)

        signatures.in.both <- intersect(subset(tbl, status=="mut")$signature, subset(tbl, status=="wt")$signature)
        signatures.only.in.wt <- setdiff(subset(tbl, status=="wt")$signature, subset(tbl, status=="mut")$signature)
        signatures.only.in.mut <- setdiff(subset(tbl, status=="mut")$signature, subset(tbl, status=="wt")$signature)

        tbl$assessed <- rep("failed", nrow(tbl))

        if(length(signatures.in.both) > 0) {
           indices <- sort(unlist(lapply(signatures.in.both, function(sig) grep(sig, tbl$signature))))
           tbl$assessed[indices] <- "in.both"
           }

        if(length(signatures.only.in.wt) > 0) {
           indices <- sort(unlist(lapply(signatures.only.in.wt, function(sig) grep(sig, tbl$signature))))
           tbl$assessed[indices] <- "wt.only"
           }

        if(length(signatures.only.in.mut) > 0) {
           indices <- sort(unlist(lapply(signatures.only.in.mut, function(sig) grep(sig, tbl$signature))))
           tbl$assessed[indices] <- "mut.only"
           }

        tbl$delta <- 0

           # find the mut scores for each of the "wt.only" entries, subtract from the wt score
        tbl.wt.only  <- subset(tbl, assessed=="wt.only", select=c(signature, motifRelativeScore))
        if(nrow(tbl.wt.only) > 0){
           sigs <- tbl.wt.only$signature
           tbl.mut.scores <- subset(tbl.mut.relaxed, signature %in% sigs, select=c(signature, motifRelativeScore))
           deltas <- unlist(lapply(sigs, function(sig){wt.score  <- subset(tbl.wt.only, signature==sig)$motifRelativeScore;
                                                mut.score <- subset(tbl.mut.scores, signature==sig)$motifRelativeScore;
                                                delta <- wt.score - mut.score
                                                }))
           tbl$delta[match(sigs, tbl$signature)] <- deltas
           } # if some wt.only entries

           # find the wt scores for each of the "mut.only" entries, subtract from the mut score

        tbl.mut.only  <- subset(tbl, assessed=="mut.only", select=c(signature, motifRelativeScore))
        if(nrow(tbl.mut.only) > 0){
           sigs <- tbl.mut.only$signature
              # find the wt scores for these muts, looking in the relaxedMatchPercentage match table
           tbl.wt.scores <- subset(tbl.wt.relaxed, signature %in% sigs, select=c(signature, motifRelativeScore))
           deltas <- unlist(lapply(sigs, function(sig){mut.score  <- subset(tbl.mut.only, signature==sig)$motifRelativeScore;
                                                       wt.score <- subset(tbl.wt.scores, signature==sig)$motifRelativeScore;
                                                       delta <- wt.score - mut.score
                                                       }))
           tbl$delta[match(sigs, tbl$signature)] <- deltas
           } # tbl.mut.only > 0

        coi <-  c("motifName", "status", "assessed", "motifRelativeScore", "delta",
                  "signature", "chrom", "motifStart", "motifEnd", "strand", "match")

        stopifnot(all(coi %in% colnames(tbl)))
        tbl <- tbl[, coi]
        tbl$variant <- variant
        tbl
        }) # assessSnp

#------------------------------------------------------------------------------------------------------------------------
